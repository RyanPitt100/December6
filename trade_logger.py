#!/usr/bin/env python3
"""
trade_logger.py

SQLite-based logging system for the trading bot.

Logs:
- All signals generated (executed or not)
- All orders placed
- All trade executions (fills)
- Account state snapshots
- Risk state changes
- Errors and warnings

Database: trades.db (SQLite)
"""

import sqlite3
import os
from datetime import datetime
from typing import Optional, List, Dict, Any
from pathlib import Path
from dataclasses import asdict

from portfolio_controller import TradeSignal, Order
from risk_manager import AccountState, Position


class TradeLogger:
    """SQLite-based logger for trading bot activity."""

    def __init__(self, db_path: str = "trades.db"):
        """
        Initialize the trade logger.

        Args:
            db_path: Path to SQLite database file
        """
        self.db_path = db_path
        self._init_database()

    def _init_database(self):
        """Create database tables if they don't exist."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Table 1: Signals generated by strategy
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS signals (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT NOT NULL,
                instrument TEXT NOT NULL,
                direction TEXT NOT NULL,
                entry_price REAL NOT NULL,
                sl_price REAL NOT NULL,
                tp_price REAL,
                reason TEXT,
                regime_h1 TEXT,
                regime_h4 TEXT,
                regime_d1 TEXT,
                executed INTEGER DEFAULT 0,
                execution_id INTEGER,
                created_at TEXT DEFAULT CURRENT_TIMESTAMP
            )
        """)

        # Table 2: Orders sent to broker
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS orders (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT NOT NULL,
                action TEXT NOT NULL,
                instrument TEXT NOT NULL,
                direction TEXT,
                entry_price REAL,
                sl_price REAL,
                tp_price REAL,
                size_lots REAL,
                status TEXT DEFAULT 'pending',
                error_message TEXT,
                created_at TEXT DEFAULT CURRENT_TIMESTAMP
            )
        """)

        # Table 3: Trade executions (fills)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS executions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                order_id INTEGER,
                timestamp TEXT NOT NULL,
                instrument TEXT NOT NULL,
                direction TEXT NOT NULL,
                entry_price REAL NOT NULL,
                sl_price REAL NOT NULL,
                tp_price REAL,
                size_lots REAL NOT NULL,
                reason TEXT,
                -- Market context at entry (for future analysis)
                atr_at_entry REAL,
                atr_percentile REAL,
                spread_at_entry REAL,
                adx_at_entry REAL,
                er_at_entry REAL,
                session TEXT,
                entry_hour INTEGER,
                entry_day_of_week INTEGER,
                created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (order_id) REFERENCES orders(id)
            )
        """)

        # Table 4: Trade closes
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS trade_closes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                execution_id INTEGER NOT NULL,
                timestamp TEXT NOT NULL,
                instrument TEXT NOT NULL,
                direction TEXT NOT NULL,
                entry_price REAL NOT NULL,
                exit_price REAL NOT NULL,
                size_lots REAL NOT NULL,
                pnl_currency REAL NOT NULL,
                pnl_pct REAL,
                r_multiple REAL,
                exit_reason TEXT,
                duration_minutes INTEGER,
                -- MAE/MFE for SL/TP optimization analysis
                mae_price REAL,
                mfe_price REAL,
                mae_pips REAL,
                mfe_pips REAL,
                mae_r REAL,
                mfe_r REAL,
                created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (execution_id) REFERENCES executions(id)
            )
        """)

        # Table 5: Account state snapshots
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS account_snapshots (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT NOT NULL,
                balance REAL NOT NULL,
                equity REAL NOT NULL,
                start_of_day_equity REAL NOT NULL,
                realised_pnl_today REAL NOT NULL,
                daily_pnl_pct REAL NOT NULL,
                total_dd_pct REAL NOT NULL,
                open_positions INTEGER NOT NULL,
                risk_state TEXT NOT NULL,
                risk_action TEXT NOT NULL,
                eval_profit_target_hit INTEGER DEFAULT 0,
                breached_daily_limit INTEGER DEFAULT 0,
                breached_total_limit INTEGER DEFAULT 0,
                created_at TEXT DEFAULT CURRENT_TIMESTAMP
            )
        """)

        # Table 6: System events (errors, warnings, info)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS system_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT NOT NULL,
                level TEXT NOT NULL,
                category TEXT NOT NULL,
                message TEXT NOT NULL,
                details TEXT,
                created_at TEXT DEFAULT CURRENT_TIMESTAMP
            )
        """)

        # Create indices for faster queries
        cursor.execute("""
            CREATE INDEX IF NOT EXISTS idx_signals_timestamp
            ON signals(timestamp)
        """)

        cursor.execute("""
            CREATE INDEX IF NOT EXISTS idx_signals_instrument
            ON signals(instrument)
        """)

        cursor.execute("""
            CREATE INDEX IF NOT EXISTS idx_executions_timestamp
            ON executions(timestamp)
        """)

        cursor.execute("""
            CREATE INDEX IF NOT EXISTS idx_account_snapshots_timestamp
            ON account_snapshots(timestamp)
        """)

        cursor.execute("""
            CREATE INDEX IF NOT EXISTS idx_system_events_timestamp
            ON system_events(timestamp)
        """)

        conn.commit()
        conn.close()

    def log_signal(
        self,
        signal: TradeSignal,
        regime_labels: Optional[Dict[str, str]] = None,
        executed: bool = False,
        execution_id: Optional[int] = None,
    ) -> int:
        """
        Log a signal generated by the strategy.

        Args:
            signal: TradeSignal object
            regime_labels: Dict with keys 'H1', 'H4', 'D1' for regime labels
            executed: Whether the signal was executed as a trade
            execution_id: ID of execution record if executed

        Returns:
            Signal ID
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        timestamp = datetime.utcnow().isoformat()

        regime_h1 = regime_labels.get("H1") if regime_labels else None
        regime_h4 = regime_labels.get("H4") if regime_labels else None
        regime_d1 = regime_labels.get("D1") if regime_labels else None

        cursor.execute("""
            INSERT INTO signals (
                timestamp, instrument, direction, entry_price, sl_price, tp_price,
                reason, regime_h1, regime_h4, regime_d1, executed, execution_id
            )
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            timestamp,
            signal.instrument,
            signal.direction,
            signal.entry_price,
            signal.sl_price,
            signal.tp_price,
            signal.reason,
            regime_h1,
            regime_h4,
            regime_d1,
            1 if executed else 0,
            execution_id,
        ))

        signal_id = cursor.lastrowid
        conn.commit()
        conn.close()

        return signal_id

    def log_order(
        self,
        order: Order,
        status: str = "pending",
        error_message: Optional[str] = None,
    ) -> int:
        """
        Log an order sent to the broker.

        Args:
            order: Order object
            status: Order status ('pending', 'filled', 'rejected', 'error')
            error_message: Error message if order failed

        Returns:
            Order ID
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        timestamp = datetime.utcnow().isoformat()

        cursor.execute("""
            INSERT INTO orders (
                timestamp, action, instrument, direction, entry_price,
                sl_price, tp_price, size_lots, status, error_message
            )
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            timestamp,
            order.action,
            order.instrument,
            order.direction if hasattr(order, 'direction') else None,
            order.entry_price if hasattr(order, 'entry_price') else None,
            order.sl_price if hasattr(order, 'sl_price') else None,
            order.tp_price if hasattr(order, 'tp_price') else None,
            order.size_lots if hasattr(order, 'size_lots') else None,
            status,
            error_message,
        ))

        order_id = cursor.lastrowid
        conn.commit()
        conn.close()

        return order_id

    def log_execution(
        self,
        order_id: Optional[int],
        instrument: str,
        direction: str,
        entry_price: float,
        sl_price: float,
        tp_price: Optional[float],
        size_lots: float,
        reason: Optional[str] = None,
        # Market context fields for analysis
        atr_at_entry: Optional[float] = None,
        atr_percentile: Optional[float] = None,
        spread_at_entry: Optional[float] = None,
        adx_at_entry: Optional[float] = None,
        er_at_entry: Optional[float] = None,
        session: Optional[str] = None,
        entry_hour: Optional[int] = None,
        entry_day_of_week: Optional[int] = None,
    ) -> int:
        """
        Log a trade execution (order filled).

        Args:
            order_id: ID of the order that was filled
            instrument: Instrument symbol
            direction: 'long' or 'short'
            entry_price: Execution price
            sl_price: Stop loss price
            tp_price: Take profit price (optional)
            size_lots: Position size in lots
            reason: Reason for trade (e.g., signal reason)
            atr_at_entry: ATR value at time of entry
            atr_percentile: ATR percentile (0-100) relative to recent history
            spread_at_entry: Spread in points at time of entry
            adx_at_entry: ADX indicator value at entry
            er_at_entry: Efficiency Ratio at entry
            session: Trading session ('london', 'ny', 'asia', 'overlap')
            entry_hour: Hour of day (0-23 UTC)
            entry_day_of_week: Day of week (0=Monday, 6=Sunday)

        Returns:
            Execution ID
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        timestamp = datetime.utcnow().isoformat()

        cursor.execute("""
            INSERT INTO executions (
                order_id, timestamp, instrument, direction, entry_price,
                sl_price, tp_price, size_lots, reason,
                atr_at_entry, atr_percentile, spread_at_entry,
                adx_at_entry, er_at_entry, session, entry_hour, entry_day_of_week
            )
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            order_id,
            timestamp,
            instrument,
            direction,
            entry_price,
            sl_price,
            tp_price,
            size_lots,
            reason,
            atr_at_entry,
            atr_percentile,
            spread_at_entry,
            adx_at_entry,
            er_at_entry,
            session,
            entry_hour,
            entry_day_of_week,
        ))

        execution_id = cursor.lastrowid
        conn.commit()
        conn.close()

        return execution_id

    def log_trade_close(
        self,
        execution_id: int,
        instrument: str,
        direction: str,
        entry_price: float,
        exit_price: float,
        size_lots: float,
        pnl_currency: float,
        pnl_pct: Optional[float] = None,
        r_multiple: Optional[float] = None,
        exit_reason: Optional[str] = None,
        duration_minutes: Optional[int] = None,
        # MAE/MFE fields for SL/TP optimization
        mae_price: Optional[float] = None,
        mfe_price: Optional[float] = None,
        mae_pips: Optional[float] = None,
        mfe_pips: Optional[float] = None,
        mae_r: Optional[float] = None,
        mfe_r: Optional[float] = None,
    ) -> int:
        """
        Log a trade close.

        Args:
            execution_id: ID of the execution being closed
            instrument: Instrument symbol
            direction: 'long' or 'short'
            entry_price: Entry price
            exit_price: Exit price
            size_lots: Position size in lots
            pnl_currency: P&L in account currency
            pnl_pct: P&L as % of account
            r_multiple: R multiple (e.g., 2.5R means 2.5x risk)
            exit_reason: Reason for exit ('tp', 'sl', 'manual', 'risk_limit')
            duration_minutes: Trade duration in minutes
            mae_price: Max Adverse Excursion price (worst price during trade)
            mfe_price: Max Favorable Excursion price (best price during trade)
            mae_pips: MAE in pips (how far price went against you)
            mfe_pips: MFE in pips (how far price went in your favor)
            mae_r: MAE as R-multiple (e.g., -0.5R means halfway to stop)
            mfe_r: MFE as R-multiple (e.g., 2.0R means price hit 2x target)

        Returns:
            Trade close ID
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        timestamp = datetime.utcnow().isoformat()

        cursor.execute("""
            INSERT INTO trade_closes (
                execution_id, timestamp, instrument, direction, entry_price,
                exit_price, size_lots, pnl_currency, pnl_pct, r_multiple,
                exit_reason, duration_minutes,
                mae_price, mfe_price, mae_pips, mfe_pips, mae_r, mfe_r
            )
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            execution_id,
            timestamp,
            instrument,
            direction,
            entry_price,
            exit_price,
            size_lots,
            pnl_currency,
            pnl_pct,
            r_multiple,
            exit_reason,
            duration_minutes,
            mae_price,
            mfe_price,
            mae_pips,
            mfe_pips,
            mae_r,
            mfe_r,
        ))

        close_id = cursor.lastrowid
        conn.commit()
        conn.close()

        return close_id

    def log_account_snapshot(
        self,
        account_state: AccountState,
        risk_state: Dict[str, Any],
    ):
        """
        Log a snapshot of account state.

        Args:
            account_state: AccountState object
            risk_state: Risk state dict from evaluate_daily_risk_state()
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        timestamp = datetime.utcnow().isoformat()

        # Calculate daily P&L %
        if account_state.start_of_day_equity > 0:
            daily_pnl_pct = (
                (account_state.equity - account_state.start_of_day_equity)
                / account_state.start_of_day_equity
                * 100.0
            )
        else:
            daily_pnl_pct = 0.0

        cursor.execute("""
            INSERT INTO account_snapshots (
                timestamp, balance, equity, start_of_day_equity, realised_pnl_today,
                daily_pnl_pct, total_dd_pct, open_positions, risk_state, risk_action,
                eval_profit_target_hit, breached_daily_limit, breached_total_limit
            )
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            timestamp,
            account_state.balance,
            account_state.equity,
            account_state.start_of_day_equity,
            account_state.realised_pnl_today,
            daily_pnl_pct,
            risk_state.get("total_dd_pct", 0.0),
            len(account_state.open_positions),
            risk_state.get("status", "UNKNOWN"),
            risk_state.get("action", "UNKNOWN"),
            1 if risk_state.get("hit_eval_profit_target", False) else 0,
            1 if risk_state.get("breached_daily_limit", False) else 0,
            1 if risk_state.get("breached_total_limit", False) else 0,
        ))

        conn.commit()
        conn.close()

    def log_event(
        self,
        level: str,
        category: str,
        message: str,
        details: Optional[str] = None,
    ):
        """
        Log a system event (info, warning, error).

        Args:
            level: 'INFO', 'WARNING', 'ERROR'
            category: Event category (e.g., 'mt5_connection', 'signal_generation', 'order_execution')
            message: Short event message
            details: Optional detailed information (e.g., stack trace)
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        timestamp = datetime.utcnow().isoformat()

        cursor.execute("""
            INSERT INTO system_events (timestamp, level, category, message, details)
            VALUES (?, ?, ?, ?, ?)
        """, (timestamp, level, category, message, details))

        conn.commit()
        conn.close()

    # --- Query methods for dashboard/analysis ---

    def get_recent_signals(self, limit: int = 20) -> List[Dict[str, Any]]:
        """Get recent signals."""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        cursor.execute("""
            SELECT * FROM signals
            ORDER BY timestamp DESC
            LIMIT ?
        """, (limit,))

        rows = cursor.fetchall()
        conn.close()

        return [dict(row) for row in rows]

    def get_open_executions(self) -> List[Dict[str, Any]]:
        """Get executions that haven't been closed yet."""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        cursor.execute("""
            SELECT e.*
            FROM executions e
            LEFT JOIN trade_closes tc ON e.id = tc.execution_id
            WHERE tc.id IS NULL
            ORDER BY e.timestamp DESC
        """)

        rows = cursor.fetchall()
        conn.close()

        return [dict(row) for row in rows]

    def get_closed_trades(self, limit: int = 50) -> List[Dict[str, Any]]:
        """Get recent closed trades."""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        cursor.execute("""
            SELECT * FROM trade_closes
            ORDER BY timestamp DESC
            LIMIT ?
        """, (limit,))

        rows = cursor.fetchall()
        conn.close()

        return [dict(row) for row in rows]

    def get_recent_account_snapshots(self, limit: int = 100) -> List[Dict[str, Any]]:
        """Get recent account snapshots."""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        cursor.execute("""
            SELECT * FROM account_snapshots
            ORDER BY timestamp DESC
            LIMIT ?
        """, (limit,))

        rows = cursor.fetchall()
        conn.close()

        return [dict(row) for row in rows]

    def get_recent_events(self, level: Optional[str] = None, limit: int = 50) -> List[Dict[str, Any]]:
        """Get recent system events, optionally filtered by level."""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        if level:
            cursor.execute("""
                SELECT * FROM system_events
                WHERE level = ?
                ORDER BY timestamp DESC
                LIMIT ?
            """, (level, limit))
        else:
            cursor.execute("""
                SELECT * FROM system_events
                ORDER BY timestamp DESC
                LIMIT ?
            """, (limit,))

        rows = cursor.fetchall()
        conn.close()

        return [dict(row) for row in rows]

    def get_trade_statistics(self) -> Dict[str, Any]:
        """Calculate trade statistics from closed trades."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Total trades
        cursor.execute("SELECT COUNT(*) FROM trade_closes")
        total_trades = cursor.fetchone()[0]

        if total_trades == 0:
            conn.close()
            return {
                "total_trades": 0,
                "win_rate": 0.0,
                "avg_win": 0.0,
                "avg_loss": 0.0,
                "profit_factor": 0.0,
                "total_pnl": 0.0,
                "avg_r_multiple": 0.0,
            }

        # Win rate
        cursor.execute("SELECT COUNT(*) FROM trade_closes WHERE pnl_currency > 0")
        wins = cursor.fetchone()[0]
        win_rate = (wins / total_trades * 100.0) if total_trades > 0 else 0.0

        # Average win/loss
        cursor.execute("SELECT AVG(pnl_currency) FROM trade_closes WHERE pnl_currency > 0")
        avg_win = cursor.fetchone()[0] or 0.0

        cursor.execute("SELECT AVG(pnl_currency) FROM trade_closes WHERE pnl_currency < 0")
        avg_loss = cursor.fetchone()[0] or 0.0

        # Profit factor
        cursor.execute("SELECT SUM(pnl_currency) FROM trade_closes WHERE pnl_currency > 0")
        total_wins = cursor.fetchone()[0] or 0.0

        cursor.execute("SELECT SUM(pnl_currency) FROM trade_closes WHERE pnl_currency < 0")
        total_losses = abs(cursor.fetchone()[0] or 0.0)

        profit_factor = (total_wins / total_losses) if total_losses > 0 else 0.0

        # Total P&L
        cursor.execute("SELECT SUM(pnl_currency) FROM trade_closes")
        total_pnl = cursor.fetchone()[0] or 0.0

        # Average R multiple
        cursor.execute("SELECT AVG(r_multiple) FROM trade_closes WHERE r_multiple IS NOT NULL")
        avg_r = cursor.fetchone()[0] or 0.0

        conn.close()

        return {
            "total_trades": total_trades,
            "wins": wins,
            "losses": total_trades - wins,
            "win_rate": win_rate,
            "avg_win": avg_win,
            "avg_loss": avg_loss,
            "profit_factor": profit_factor,
            "total_pnl": total_pnl,
            "avg_r_multiple": avg_r,
        }


# Global logger instance
_logger: Optional[TradeLogger] = None


def get_logger(db_path: str = "trades.db") -> TradeLogger:
    """
    Get or create the global logger instance.

    Args:
        db_path: Path to SQLite database file

    Returns:
        TradeLogger instance
    """
    global _logger
    if _logger is None:
        _logger = TradeLogger(db_path)
    return _logger


# ---------------------------------------------------------------------------
# Helper functions for market context
# ---------------------------------------------------------------------------

def get_trading_session(timestamp: datetime) -> str:
    """
    Determine the trading session for a given timestamp.

    Sessions (UTC times):
        - Asia: 00:00 - 08:00 (Tokyo/Sydney)
        - London: 08:00 - 16:00
        - NY: 13:00 - 21:00
        - London/NY overlap: 13:00 - 16:00

    Args:
        timestamp: datetime object (assumed UTC)

    Returns:
        Session name: 'asia', 'london', 'ny', 'london_ny_overlap', 'off_hours'
    """
    hour = timestamp.hour

    # Define session boundaries (UTC)
    asia_start, asia_end = 0, 8
    london_start, london_end = 8, 16
    ny_start, ny_end = 13, 21

    # Check for overlap first
    if london_start <= hour < london_end and ny_start <= hour < ny_end:
        return "london_ny_overlap"
    elif asia_start <= hour < asia_end:
        return "asia"
    elif london_start <= hour < london_end:
        return "london"
    elif ny_start <= hour < ny_end:
        return "ny"
    else:
        return "off_hours"


def get_entry_context(timestamp: datetime) -> Dict[str, Any]:
    """
    Get time-based context for an entry.

    Args:
        timestamp: Entry timestamp (assumed UTC)

    Returns:
        Dict with session, hour, and day_of_week
    """
    return {
        "session": get_trading_session(timestamp),
        "entry_hour": timestamp.hour,
        "entry_day_of_week": timestamp.weekday(),  # 0=Monday, 6=Sunday
    }
