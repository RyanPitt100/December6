#!/usr/bin/env python3
"""
replay_last_2_weeks.py

Fetch the last 2 weeks of data from MT5 and replay what signals/trades
would have been generated by the live runner.

This helps diagnose why no trades were taken during live running.

Usage:
    python replay_last_2_weeks.py
    python replay_last_2_weeks.py --days 14
    python replay_last_2_weeks.py --days 30 --verbose
"""

import argparse
from datetime import datetime, timedelta
from typing import List, Dict, Optional
from dataclasses import dataclass
import pandas as pd

# MT5 imports
try:
    import MetaTrader5 as mt5
    MT5_AVAILABLE = True
except ImportError:
    MT5_AVAILABLE = False
    print("[WARNING] MetaTrader5 not installed. Install with: pip install MetaTrader5")

from config_loader import load_all_configs
from mt5_multi_tf_builder import build_multi_tf_from_mt5, _get_regime_params_for_instrument
from regime_labeler import label_regimes, RegimeParams
from strategies import TrendEMAPullback, TrendEMAPullbackParams
from live_signal_generator import generate_signals_for_portfolio


@dataclass
class ReplaySignal:
    timestamp: pd.Timestamp
    instrument: str
    direction: str
    entry_price: float
    sl_price: float
    tp_price: Optional[float]
    regime_h1: str
    regime_h4: str


def init_mt5() -> bool:
    """Initialize MT5 connection."""
    if not MT5_AVAILABLE:
        return False

    if not mt5.initialize():
        print(f"[ERROR] MT5 initialize failed: {mt5.last_error()}")
        return False

    print(f"[OK] MT5 initialized: {mt5.terminal_info().name}")
    return True


def fetch_ohlc_mt5(symbol: str, timeframe_str: str, n_bars: int) -> Optional[pd.DataFrame]:
    """Fetch OHLC data from MT5."""
    tf_map = {
        "15m": mt5.TIMEFRAME_M15,
        "1h": mt5.TIMEFRAME_H1,
        "4h": mt5.TIMEFRAME_H4,
        "1d": mt5.TIMEFRAME_D1,
    }

    tf = tf_map.get(timeframe_str)
    if tf is None:
        print(f"[ERROR] Unknown timeframe: {timeframe_str}")
        return None

    rates = mt5.copy_rates_from_pos(symbol, tf, 0, n_bars)
    if rates is None or len(rates) == 0:
        print(f"[ERROR] Failed to fetch {symbol} {timeframe_str}: {mt5.last_error()}")
        return None

    df = pd.DataFrame(rates)
    df['timestamp'] = pd.to_datetime(df['time'], unit='s', utc=True)
    df = df.rename(columns={'tick_volume': 'volume'})
    df = df[['timestamp', 'open', 'high', 'low', 'close', 'volume']]
    df = df.set_index('timestamp').sort_index()

    return df


def build_multi_tf_for_replay(symbol: str, n_bars_15m: int = 2000) -> Optional[pd.DataFrame]:
    """
    Build multi-timeframe DataFrame from MT5 with regime labels.
    Similar to mt5_multi_tf_builder but uses direct MT5 calls.
    """
    # Fetch all timeframes
    df_15m = fetch_ohlc_mt5(symbol, "15m", n_bars_15m)
    if df_15m is None:
        return None

    df_h1 = fetch_ohlc_mt5(symbol, "1h", 500)
    df_h4 = fetch_ohlc_mt5(symbol, "4h", 500)
    df_d1 = fetch_ohlc_mt5(symbol, "1d", 500)

    if df_h1 is None or df_h4 is None or df_d1 is None:
        print(f"[WARNING] Missing higher TF data for {symbol}, skipping")
        return None

    # Label regimes using pre-computed thresholds
    params_h1 = _get_regime_params_for_instrument(symbol, "1h")
    params_h4 = _get_regime_params_for_instrument(symbol, "4h")
    params_d1 = _get_regime_params_for_instrument(symbol, "1d")

    df_h1_labeled = label_regimes(df_h1, params_h1)
    df_h4_labeled = label_regimes(df_h4, params_h4)
    df_d1_labeled = label_regimes(df_d1, params_d1)

    # Reset index for merging
    df_15m = df_15m.reset_index()
    df_h1_labeled = df_h1_labeled.reset_index()
    df_h4_labeled = df_h4_labeled.reset_index()
    df_d1_labeled = df_d1_labeled.reset_index()

    # Merge regime labels
    df_15m = pd.merge_asof(
        df_15m.sort_values("timestamp"),
        df_h1_labeled[["timestamp", "regime", "range_score"]].sort_values("timestamp"),
        on="timestamp",
        direction="backward"
    )
    df_15m.rename(columns={"regime": "regime_h1", "range_score": "range_score_h1"}, inplace=True)

    df_15m = pd.merge_asof(
        df_15m.sort_values("timestamp"),
        df_h4_labeled[["timestamp", "regime"]].sort_values("timestamp"),
        on="timestamp",
        direction="backward"
    )
    df_15m.rename(columns={"regime": "regime_h4"}, inplace=True)

    df_15m = pd.merge_asof(
        df_15m.sort_values("timestamp"),
        df_d1_labeled[["timestamp", "regime"]].sort_values("timestamp"),
        on="timestamp",
        direction="backward"
    )
    df_15m.rename(columns={"regime": "regime_d1"}, inplace=True)

    df_15m = df_15m.set_index("timestamp").sort_index()

    return df_15m


def replay_signals(
    instruments: List[str],
    days: int = 14,
    verbose: bool = False,
) -> List[ReplaySignal]:
    """
    Replay the last N days and find all signals that would have been generated.
    """
    print("=" * 70)
    print(f"REPLAY LAST {days} DAYS - SIGNAL GENERATION")
    print("=" * 70)

    # Calculate bars needed (15m bars)
    # 14 days * 24 hours * 4 bars/hour = 1344 bars
    # Add buffer for indicator warmup
    n_bars = days * 24 * 4 + 500

    all_signals: List[ReplaySignal] = []
    instrument_data: Dict[str, pd.DataFrame] = {}

    # Load data for each instrument
    print(f"\n[1/3] Fetching MT5 data for {len(instruments)} instruments...")
    for symbol in instruments:
        print(f"  Loading {symbol}...", end=" ")
        df = build_multi_tf_for_replay(symbol, n_bars_15m=n_bars)
        if df is not None:
            instrument_data[symbol] = df
            print(f"OK ({len(df)} bars)")
        else:
            print("FAILED")

    if not instrument_data:
        print("[ERROR] No instrument data loaded")
        return []

    # Determine replay window
    cutoff_date = datetime.now(tz=pd.Timestamp.now().tz or None) - timedelta(days=days)
    cutoff_ts = pd.Timestamp(cutoff_date, tz='UTC')

    # Get common timestamp range
    all_timestamps = set()
    for df in instrument_data.values():
        recent = df[df.index >= cutoff_ts]
        all_timestamps.update(recent.index.tolist())

    timestamps = sorted(all_timestamps)
    print(f"\n[2/3] Replaying {len(timestamps)} bars from {timestamps[0]} to {timestamps[-1]}...")

    # Track regime states for debugging
    regime_stats = {sym: {"TRENDING": 0, "RANGING": 0, "MIXED": 0} for sym in instruments}

    # Replay bar-by-bar
    signals_found = 0
    strategy = TrendEMAPullback(params=TrendEMAPullbackParams())

    for i, ts in enumerate(timestamps):
        # Generate signals for this bar
        signals = generate_signals_for_portfolio(
            instrument_data=instrument_data,
            current_ts=ts,
            portfolio_instruments=list(instrument_data.keys()),
            params=None,
        )

        # Track regime states
        for symbol, df in instrument_data.items():
            if ts in df.index:
                row = df.loc[ts]
                h1 = row.get("regime_h1", "UNKNOWN")
                h4 = row.get("regime_h4", "UNKNOWN")

                if h1 == "TRENDING" and h4 == "TRENDING":
                    regime_stats[symbol]["TRENDING"] += 1
                elif h1 == "RANGING" or h4 == "RANGING":
                    regime_stats[symbol]["RANGING"] += 1
                else:
                    regime_stats[symbol]["MIXED"] += 1

        if signals:
            for sig in signals:
                replay_sig = ReplaySignal(
                    timestamp=ts,
                    instrument=sig.instrument,
                    direction=sig.direction,
                    entry_price=sig.entry_price,
                    sl_price=sig.sl_price,
                    tp_price=sig.tp_price,
                    regime_h1=instrument_data[sig.instrument].loc[ts].get("regime_h1", "?"),
                    regime_h4=instrument_data[sig.instrument].loc[ts].get("regime_h4", "?"),
                )
                all_signals.append(replay_sig)
                signals_found += 1

                if verbose:
                    tp_str = f"{sig.tp_price:.5f}" if sig.tp_price else "None"
                    print(f"  [SIGNAL] {ts} {sig.instrument} {sig.direction.upper()} @ {sig.entry_price:.5f}")

        # Progress
        if (i + 1) % 500 == 0:
            print(f"    Progress: {i+1}/{len(timestamps)} bars, {signals_found} signals found")

    # Summary
    print(f"\n[3/3] RESULTS")
    print("=" * 70)
    print(f"Period: {timestamps[0]} to {timestamps[-1]}")
    print(f"Bars analyzed: {len(timestamps)}")
    print(f"Signals generated: {len(all_signals)}")

    if all_signals:
        print(f"\nSignals by instrument:")
        by_inst = {}
        for sig in all_signals:
            by_inst[sig.instrument] = by_inst.get(sig.instrument, 0) + 1
        for inst, count in sorted(by_inst.items()):
            print(f"  {inst}: {count}")

        print(f"\nAll signals:")
        for sig in all_signals:
            tp_str = f"{sig.tp_price:.5f}" if sig.tp_price else "None"
            print(f"  {sig.timestamp} {sig.instrument} {sig.direction.upper()} @ {sig.entry_price:.5f} (SL: {sig.sl_price:.5f}, TP: {tp_str})")
            print(f"    Regimes: H1={sig.regime_h1}, H4={sig.regime_h4}")

    print(f"\nRegime breakdown (bars where H1+H4 both TRENDING vs not):")
    for symbol in instruments:
        if symbol in regime_stats:
            stats = regime_stats[symbol]
            total = sum(stats.values())
            trending_pct = stats["TRENDING"] / total * 100 if total > 0 else 0
            print(f"  {symbol}: {stats['TRENDING']}/{total} bars TRENDING ({trending_pct:.1f}%)")

    print("=" * 70)

    return all_signals


def main():
    parser = argparse.ArgumentParser(description="Replay last N days of MT5 data")
    parser.add_argument("--days", type=int, default=14, help="Number of days to replay (default: 14)")
    parser.add_argument("--verbose", action="store_true", help="Print each signal as found")
    args = parser.parse_args()

    # Initialize MT5
    if not init_mt5():
        print("[ERROR] Could not initialize MT5. Make sure MT5 is running.")
        return

    try:
        # Load portfolio config
        portfolio_cfg, _, _ = load_all_configs()
        instruments = [inst.symbol for inst in portfolio_cfg.instruments]
        print(f"[OK] Portfolio instruments: {instruments}")

        # Run replay
        signals = replay_signals(
            instruments=instruments,
            days=args.days,
            verbose=args.verbose,
        )

        if not signals:
            print("\n[RESULT] NO SIGNALS generated in the last {args.days} days!")
            print("This could mean:")
            print("  1. Market conditions didn't meet strategy criteria (H1+H4 both TRENDING)")
            print("  2. No valid pullback setups occurred")
            print("  3. There may still be bugs in signal generation")
        else:
            print(f"\n[RESULT] {len(signals)} signals would have been generated")
            print("If the live runner didn't take these trades, there's likely a bug.")

    finally:
        mt5.shutdown()


if __name__ == "__main__":
    main()
